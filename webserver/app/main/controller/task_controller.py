import aiofiles
import os
import uuid
from async_files.utils import async_wraps
from pathlib import Path
from datetime import date, datetime, timedelta

from sanic import Blueprint
from sanic.log import logger
from sanic.views import HTTPMethodView
from sanic.response import json, file, html
from sanic_openapi import doc
from marshmallow.exceptions import ValidationError

from ..util.decorator import token_required, organization_team_required_by_args, organization_team_required_by_json, task_required
from ..util.get_path import get_test_result_path
from ..util import js2python_bool, async_exists
from ..util.eventqueue import push_event
from ..util.tarball import path_to_dict
from ..model.database import Task, Test, Endpoint, TaskQueue, EVENT_CODE_CANCEL_TASK, EVENT_CODE_START_TASK, QUEUE_PRIORITY_DEFAULT, QUEUE_PRIORITY_MAX, QUEUE_PRIORITY_MIN
from ..util.dto import TaskDto, json_response, organization_team
from ..config import get_config
from ..util.response import response_message, EINVAL, ENOENT, SUCCESS, ERANGE, EPERM, UNKNOWN_ERROR

_task = TaskDto.task
_task_query = TaskDto.task_query
_run_task = TaskDto.run_task
_task_id = TaskDto.task_id
_task_result_files = TaskDto.task_result_files
_task_update = TaskDto.task_update
_task_cancel = TaskDto.task_cancel
_task_stat_list = TaskDto.task_stat_list

bp = Blueprint('task', url_prefix='/task')

@bp.get('/result')
@doc.summary('Get the task result XML file generated by robot')
@doc.consumes(doc.String(name='X-Token'), location='header')
@doc.consumes(_task_id)
@doc.response(201, doc.String(), description='the XML file content')
@doc.response(200, json_response)
@token_required
@organization_team_required_by_args
@task_required
async def handler(request):
    task = request.ctx.task

    result_dir = await get_test_result_path(task)
    if not await async_exists(result_dir):
        return json(response_message(ENOENT, 'Task result directory not found')) #TODO

    async with aiofiles.open(result_dir / 'output.xml', encoding='utf-8') as f:
        return html(await f.read(), headers={'Content-Type': 'text/xml'})
        # return text(await f.read(), headers={'Content-Type': 'text/xml'}) #TODO

@bp.get('/result_files')
@doc.summary('Get the test result file list')
@doc.consumes(doc.String(name='X-Token'), location='header')
@doc.consumes(_task_id)
@doc.produces(_task_result_files)
@token_required
@organization_team_required_by_args
@task_required
async def handler(request):
    task = request.ctx.task

    result_dir = await get_test_result_path(task)
    if not await async_exists(result_dir):
        return json(response_message(ENOENT, 'Task result directory not found'))

    result_files = await async_wraps(path_to_dict)(result_dir)

    return json(response_message(SUCCESS, files=result_files))

@bp.get('/result_file')
@doc.summary('Get the test result file')
@doc.consumes(doc.String(name='X-Token'), location='header')
@doc.consumes(_task_id)
@doc.consumes(doc.String(name='file', description='The file path', required=True))
@doc.produces(201, doc.File())
@doc.produces(200, json_response)
@token_required
@organization_team_required_by_args
@task_required
async def handler(request):
    file_path = request.args.get('file', default=None)
    if not file_path:
        return json(response_message(EINVAL, 'Field file is required'))

    task = request.ctx.task

    result_dir = await get_test_result_path(task)
    return await file(result_dir / file_path, status=201) # as_attachment=True) #TODO

class TaskView(HTTPMethodView):
    @doc.summary('Get the task statistics list of last 7 days')
    @doc.description('The result is a list of task statistics of each day')
    @doc.consumes(doc.String(name='X-Token'), location='header')
    @doc.consumes(_task_query)
    @doc.produces(_task_stat_list)
    @token_required
    @organization_team_required_by_args
    async def get(self, request):
        organization = request.ctx.organization
        team = request.ctx.team

        start_date = request.args.get('start_date', default=(datetime.utcnow().timestamp()-86300)*1000)
        end_date = request.args.get('end_date', default=(datetime.utcnow().timestamp() * 1000))

        start_date = datetime.fromtimestamp(int(start_date)/1000)
        end_date = datetime.fromtimestamp(int(end_date)/1000)

        if (start_date - end_date).days > 0:
            return json(response_message(EINVAL, 'start date {} is larger than end date {}'.format(start_date, end_date)))

        delta = end_date - start_date
        days = delta.days
        if delta % timedelta(days=1):
            days = days + 1

        stats = []
        start = start_date
        end = start + timedelta(days=1) 

        query = {'organization': organization.pk, 'team': team.pk if team else None}
        query2 = {'status': 'waiting', 'organization': organization.pk, 'team': team.pk if team else None}

        for d in range(days):
            if d == (days - 1):
                end = end_date
            query['run_date'] = {'$gte': start, '$lte': end} #TODO
            query2['schedule_date'] = {'$gte': start, '$lte': end}

            query['status'] = 'successful'
            succeeded = await Task.count_documents(query)

            query['status'] = 'failed'
            failed = await Task.count_documents(query)

            query['status'] = 'running'
            running = await Task.count_documents(query)

            waiting = await Task.count_documents(query2)
            
            stats.append({
                'succeeded': succeeded,
                'failed': failed,
                'running': running,
                'waiting': waiting,
            })

            start = start + timedelta(days=1)
            end = start + timedelta(days=1)
        return json(response_message(SUCCESS, stats=stats))

    @doc.summary('Run a test suite')
    @doc.consumes(doc.String(name='X-Token'), location='header')
    @doc.consumes(_task, location='body')
    @doc.produces(_run_task)
    @token_required
    @organization_team_required_by_json
    async def post(self, request):
        data = request.json
        if data is None:
            return json(response_message(EINVAL, 'The request data is empty'))

        task = Task()
        test_suite = data.get('test_suite', None)
        if test_suite == None:
            return json(response_message(EINVAL, 'Field test_suite is required'))
        test_path = data.get('path', None)
        if test_path == None:
            return json(response_message(EINVAL, 'Field path is required'))

        task.test_suite = test_suite

        organization = request.ctx.organization
        team = request.ctx.team
        user = request.ctx.user

        query = {'test_suite': task.test_suite, 'path': test_path, 'organization': organization.pk, 'team': team.pk if team else None}
        test = await Test.find_one(query)
        if not test:
            return json(response_message(ENOENT, 'The requested test suite is not found'))
        if await Test.count_documents(query) != 1:
            return json(response_message(EINVAL, 'Found duplicate test suites'))

        endpoint_list = data.get('endpoint_list', None)
        if endpoint_list == None:
            return json(response_message(EINVAL, 'Endpoint list is not included in the request'))
        if not isinstance(endpoint_list, list):
            return json(response_message(EINVAL, 'Endpoint list is not a list'))
        if len(endpoint_list) == 0:
            return json(response_message(EINVAL, 'Endpoint list is empty'))
        for uid in endpoint_list:
            if not await Endpoint.find_one({'uid': uuid.UUID(uid)}):
                return json(response_message(EINVAL, 'One of the uid in the endpoint list is invalid'))
        task.endpoint_list = endpoint_list  # convert to uuid.UUID when assigning

        priority = int(data.get('priority', QUEUE_PRIORITY_DEFAULT))
        if priority < QUEUE_PRIORITY_MIN or priority > QUEUE_PRIORITY_MAX:
            return json(response_message(ERANGE, 'Task priority is out of range'))
        task.priority = priority

        parallelization = js2python_bool(data.get('parallelization', False))
        task.parallelization = parallelization == True

        variables = data.get('variables', {})
        if not isinstance(variables, dict):
            return json(response_message(EINVAL, 'Variables should be a dictionary'))
        task.variables = variables

        testcases = data.get('test_cases', [])
        if not isinstance(testcases, list):
            return json(response_message(EINVAL, 'Testcases should be a list'))
        task.testcases = testcases

        try:
            task.tester = user
            task.upload_dir = data.get('upload_dir', '')
            task.test = test
            task.organization = organization
            if team:
                task.team = team
        except ValidationError as e:
            logger.exception(e)
            return json(response_message(EINVAL, 'Task validation failed'))
        await task.commit()

        failed = []
        succeeded = []
        running = []
        for endpoint_uid in task.endpoint_list:
            if task.parallelization:
                new_task = Task()
                for name in task:
                    if name != 'id' and not name.startswith('_') and not callable(task[name]):
                        new_task[name] = task[name]
                else:
                    await new_task.commit()
                    endpoint = await Endpoint.find_one({'uid': endpoint_uid})
                    if not endpoint:
                        failed.append(str(new_task.pk))
                        logger.error('Endpoint not found')
                        continue
                    taskqueue = await TaskQueue.find_one({'endpoint': endpoint.pk, 'priority': task.priority, 'organization': organization.pk, 'team': team.pk if team else None})
                    if not taskqueue:
                        failed.append(str(new_task.pk))
                        logger.error('Task queue not found')
                    else:
                        if not taskqueue.running_task and len(taskqueue.tasks) == 0:
                            running.append(str(new_task.pk))
                        ret = await taskqueue.push(new_task)
                        if ret == None:
                            failed.append(str(new_task.pk))
                            logger.error('Failed to push task to the task queue')
                        else:
                            message = {
                                'endpoint_uid': endpoint_uid,
                                'task_id': str(new_task.pk),
                            }
                            ret = await push_event(organization=new_task.test.organization, team=new_task.test.team, code=EVENT_CODE_START_TASK, message=message)
                            if not ret:
                                return json(response_message(EPERM, 'Pushing the event to event queue failed'))
                            succeeded.append(str(new_task.pk))
            else:
                endpoint = await Endpoint.find_one({'uid': endpoint_uid})
                if not endpoint:
                    failed.append(str(task.pk))
                    logger.error('Endpoint not found')
                    continue
                taskqueue = await TaskQueue.find_one({'endpoint': endpoint.pk, 'priority': task.priority, 'organization': organization.pk, 'team': team.pk if team else None})
                if not taskqueue:
                    failed.append(str(task.pk))
                    logger.error('Task queue not found')
                else:
                    if not taskqueue.running_task and (not taskqueue.tasks or len(taskqueue.tasks) == 0):
                        running.append(str(task.pk))
                    try:
                        await taskqueue.push(task)
                    except RuntimeError:
                        failed.append(str(task.pk))
                        logger.error('Failed to push task to the task queue')
                    else:
                        message = {
                            'endpoint_uid': endpoint_uid,
                            'task_id': str(task.pk),
                        }
                        ret = await push_event(organization=organization, team=team, code=EVENT_CODE_START_TASK, message=message)
                        if not ret:
                            return json(response_message(EPERM, 'Pushing the event to event queue failed'))
                        succeeded.append(str(task.pk))
        else:
            if task.parallelization:
                task.delete()
        if len(failed) != 0:
            return json(response_message(UNKNOWN_ERROR, 'Task scheduling failed'))
        return json(response_message(SUCCESS, failed=failed, succeeded=succeeded, running=[t for t in running if t in succeeded]))

    @doc.summary('Update a task with specified fields')
    @doc.consumes(doc.String(name='X-Token'), location='header')
    @doc.consumes(_task_update, location='body')
    @doc.produces(json_response)
    @token_required
    @organization_team_required_by_json
    @task_required
    async def patch(self, request):
        task = request.ctx.task
        data = request.json

        comment = data.get('comment', None)
        if not comment:
            return json(response_message(EINVAL, 'Field comment is required'))

        task.comment = comment
        await task.commit()

        return json(response_message(SUCCESS))

    @doc.summary('Cancel a task')
    @doc.description('The task will be removed from the queue. The running task will be terminated.')
    @doc.consumes(doc.String(name='X-Token'), location='header')
    @doc.consumes(_task_cancel, location='body')
    @doc.produces(json_response)
    @token_required
    @organization_team_required_by_json
    @task_required
    async def delete(self, request):
        task = request.ctx.task
        data = request.json

        priority = data.get('priority', None)
        if priority is None:
            return json(response_message(EINVAL, 'Field priority is required'))

        endpoint = await task.endpoint_run.fetch() if task.endpoint_run else None
        message = {
            'endpoint_uid': endpoint.uid if endpoint else '',  #TODO str(uid)
            'priority': priority,
            'task_id': str(task.pk)
        }

        test = await task.test.fetch()
        organization = await test.organization.fetch()
        team = await test.team.fetch() if test.team else None
        ret = await push_event(organization=organization, team=team, code=EVENT_CODE_CANCEL_TASK, message=message)
        if not ret:
            return json(response_message(EPERM, 'Pushing the event to event queue failed'))
        return json(response_message(SUCCESS))

bp.add_route(TaskView.as_view(), '/')
